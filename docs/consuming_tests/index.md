# Consuming Tests (Fixtures) Generated by execution-spec-tests

@ethereum/execution-spec-tests generates JSON test fixtures in different formats that can be consumed by execution clients in different ways.

## Client-consumption fixture formats

Consumed directly by the execution client, and require implementation of a fixture "consumer".

- [Blockchain Tests](./blockchain_test.md): Tests contained in the `./fixtures/blockchain_tests/` folder can be consumed directly by the client by implementing a command analogous to the go-ethereum's `evm blocktest` command (see [cmd/evm/blockrunner.go](https://github.com/ethereum/go-ethereum/blob/509a64ffb9405942396276ae111d06f9bded9221/cmd/evm/blockrunner.go#L39)).
- [State Tests](./state_test.md): Tests contained in the `./fixtures/state_tests/` folder can be consumed directly by the client by implementing a command analogous to the go-ethereum's `evm statetest` command (see [cmd/evm/staterunner.go](https://github.com/ethereum/go-ethereum/blob/509a64ffb9405942396276ae111d06f9bded9221/cmd/evm/staterunner.go#L35)).

## Hive-consumption fixture formats

Consumed by hive and executed against a fully instantiated client instance using the Engine API and other RPC endpoints.

- [Blockchain Hive Tests](./blockchain_test_hive.md): Tests contained in the `./fixtures/blockchain_tests_hive/` folder can be consumed running the [Hive `pyspec` simulator](https://github.com/ethereum/hive/tree/master/simulators/ethereum/pyspec#readme).

Here's a top-level comparison of these two approaches:

| Consumed via | Scope | Pros | Cons |
| --- | --- | --- | --- |
| `blocktest`-like command | Module test | - Fast feedback loop<br/>- Less complex | - Smaller coverage scope<br/>- Requires a dedicated interface to the client EVM to consume the JSON fixtures and execute tests |
| `hive --sim ethereum/pyspec` | System test / Integration test | - Wider Coverage Scope<br/>- Tests more of the client stack | - Slower feedback loop<br/>- Harder to debug<br/>- Post-Merge forks only (requires the Engine API) |

!!! note "Executing a `t8n` tool via `fill` is not considered to be the actual test"

    The `fill` command uses `t8n` tools to generate fixtures. Whilst this will provide basic sanity checking of EVM behavior and a sub-set of post conditions are typically checked within test cases, it is not considered the actual test. The actual test is the execution of the fixture against the EVM which will check the entire post allocation and typically use different code paths than `t8n` commands.

!!! note "Running `blocktest`, `statetest`, directly within the execution-spec-tests framework"

    It's possible to execute `evm blocktest` directly within the execution-spec-tests framework. This is intended to verify fixture generation, see [Debugging `t8n` Tools](../getting_started/debugging_t8n_tools.md).


## Release Formats

The @ethereum/execution-spec-tests repository provides [releases](https://github.com/ethereum/execution-spec-tests/releases) of fixtures in various formats (as of 2023-10-16):

| Release Artifact               | Consumer | Fork/feature scope |
| ------------------------------ | -------- | ------------------ |
| `fixtures.tar.gz`              | Clients  | All tests until the last stable fork | "Must pass" |
| `fixtures_develop.tar.gz`      | Clients  | All tests until the last development fork |

## Obtaining the Most Recent Release Artifacts

Artifacts can be downloaded directly from [the release page](https://github.com/ethereum/execution-spec-tests/releases). The following script demonstrates how the most recent release version of a specific artifact can be downloaded using the Github API:

```bash
#!/bin/bash

# requires jq
# sudo apt install jq

# The following two artifacts are intended for consumption by clients:
# - fixtures.tar.gz: Generated up to the last deployed fork.
# - fixtures_develop.tar.gz: Generated up to and including the latest dev fork.
# As of Oct 2023, dev is Cancun, deployed is Shanghai.

ARTIFACT="fixtures_develop.tar.gz"  

OWNER="ethereum"
REPO="execution-spec-tests"

DOWNLOAD_URL=$(curl -s https://api.github.com/repos/$OWNER/$REPO/releases/latest \
                   | jq -r '.assets[] | select(.name=="'$ARTIFACT'").browser_download_url')

# Sanity check for the download URL: contains a version tag prefixed with "v"
if [[ "$DOWNLOAD_URL" =~ v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
    curl -LO $DOWNLOAD_URL
else
    echo "Error: URL does not contain a valid version tag (URL: ${DOWNLOAD_URL})."
    exit 1
fi
```
